# Флоу бронювання та покупки квитка


## 1. Перегляд концертів та вибір квитка
1. **Користувач переглядає список концертів** на сторінці `/concerts`
2. **Користувач вибирає конкретний концерт** і переходить на сторінку з деталями концерту (`/concerts/:id`)
3. **Користувач бачить доступні квитки** з інформацією про місце та ціну
4. **Користувач натискає кнопку "Бронювати"** на обраному квитку

## 2. Постановка квитка в чергу та очікування
1. **Запит на бронювання відправляється на сервер** (`POST /tickets/:id/queue`)
2. **Сервер перевіряє доступність квитка** - якщо квиток уже недоступний, повертається помилка
3. **Сервер ставить запит у чергу** з використанням Redis:
* Генерується унікальний ID елемента черги
* Запит додається до списку Redis
* Оновлюється статус квитка на "в черзі" (TicketStatus.IN_QUEUE)
* Визначається позиція в черзі
4. **Клієнт отримує інформацію про позицію в черзі**
5. **Клієнт регулярно опитує сервер для оновлення інформації про позицію** (`GET /tickets/queue/:queueId`)
6. **Паралельно відбувається WebSocket підписка** - клієнт може отримувати оновлення в реальному часі

## 3. Обробка черги та резервація квитка
1. **Worker-процес (Bull job) обробляє елементи черги** за принципом FIFO (перший прийшов - перший обслужений)
2. **Коли черга дійшла до нашого запиту**:
* Worker встановлює блокування (lock) на квиток за допомогою Redis SETNX
* Перевіряється, чи квиток все ще має статус "в черзі"
* Виконується атомарна операція резервації
3. **Резервація квитка**:
* Змінюється статус квитка на "зарезервований" (TicketStatus.RESERVED)
* Квиток додається до кошика користувача
* Встановлюється таймер резервації (зазвичай 15 хвилин)
* Інформація про резервацію зберігається в Redis з TTL (time-to-live)
4. **Клієнт отримує сповіщення про успішну резервацію** через WebSocket або при опитуванні API

## 4. Робота з кошиком та таймером резервації
1. **Користувач перенаправляється в кошик** (`/cart`) або може самостійно перейти туди
2. **У кошику відображаються зарезервовані квитки** з таймером зворотного відліку
3. **Таймер резервації** показує, скільки часу залишилось до закінчення резервації
4. **Користувач може**:
* Продовжити покупку, натиснувши "Оформити замовлення"
* Видалити квиток з кошика, натиснувши "Видалити"
* Покинути сторінку (в цьому випадку резервація автоматично скасується після закінчення таймера)

## 5. Фонова обробка прострочених резервацій
1. **Фоновий процес (Cron job) періодично сканує прострочені резервації**
2. **Для кожної простроченої резервації**:
* Встановлюється блокування на квиток
* Квиток видаляється з кошика
* Статус квитка змінюється назад на "доступний" (TicketStatus.AVAILABLE)
* Інформація про резервацію видаляється з Redis
3. **Через WebSocket клієнти отримують сповіщення** про закінчення резервації (якщо вони ще на сайті)

## 6. Оформлення замовлення
1. **Користувач натискає "Оформити замовлення"** в кошику
2. **Сервер перевіряє валідність резервацій**:
* Чи не закінчився час резервації
* Чи всі квитки все ще мають статус "зарезервований"
3. **Створюється замовлення** в рамках транзакції:
* Створюється запис в таблиці замовлень (orders)
* Для кожного квитка створюється запис в таблиці елементів замовлення (order_items)
* Статус квитків змінюється на "продано" (TicketStatus.SOLD)
* Квитки видаляються з кошика
4. **Користувач перенаправляється на сторінку оплати** або на сторінку замовлення

## Механізми захисту від проблем
1. **Атомарні операції через Redis** для запобігання race conditions
2. **Система блокувань (locking)** для забезпечення консистентності даних
3. **Черга для рівномірного розподілу навантаження** і забезпечення справедливого доступу
4. **Тимчасова резервація з автоматичним скасуванням** для запобігання "зависанню" квитків
5. **Транзакції на рівні бази даних** для забезпечення ACID-властивостей при критичних операціях